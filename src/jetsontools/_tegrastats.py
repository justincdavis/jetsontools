# Copyright (c) 2024 Justin Davis (davisjustin302@gmail.com)
#
# MIT License
# ruff: noqa: S404, S603
from __future__ import annotations

import logging
import multiprocessing as mp
import subprocess
import time
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from types import TracebackType

    from typing_extensions import Self

_log = logging.getLogger(__name__)


def parse_tegrastats(file: Path) -> list[dict[str, str]]:
    """
    Parse a file written by Tegrastats or tegrastats.
    
    This a general purpose parser which does not seperate entries
    or handle types. All values are still strings in original format.
    
    The differences from raw entry/values are:
    1. values such as (cached 0MB) become entires: CACHED: 0MB. However
    these pieces of data are part of a two-piece entry for the memory
    subsystems, so representation in fixed format (dict[str, str])
    required a change.
    2. temperature entries such as cpu@49.01C become: CPU_TEMP: 49.01C
    This change upholds that all data generated from tegrastats has
    uppercase keys and that cpu frequencies will not clash with cpu
    temperature.

    Whether or not the file was written by the class Tegrastats
    or directly by tegrastats will be determined automatically.
    Output generated by Tegrastats (Python class) will have
    a timestamp field. The Python timestamp is present as 'timestamp'.

    Example entry (from Orin AGX 64GB):
    {
    'timestamp': '1729630462.0975535',  # optional entry
    'DATE': '10-22-2024',
    'TIME': '15:54:22',
    'RAM': '23336/62841MB',
    'LFB': '199x4MB',
    'SWAP': '0/31421MB',
    'CACHED': '0MB',
    'CPU': '[0%@2201,50%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201]',
    'GR3D_FREQ': '0%',
    'CPU_TEMP': '48.812C',
    'TBOARD_TEMP': '38.5C',
    'SOC2_TEMP': '44.843C',
    'TDIODE_TEMP': '38.875C',
    'SOC0_TEMP': '46.156C',
    'GPU_TEMP': '43.687C',
    'TJ_TEMP': '48.812C',
    'SOC1_TEMP': '45.656C',
    'VDD_GPU_SOC': '5191mW/5190mW',
    'VDD_CPU_CV': '1996mW/2032mW',
    'VIN_SYS_5V0': '4528mW/4539mW',
    'VDDQ_VDD2_1V8AO': '401mW/411mW'
    }
    
    Parameters
    ----------
    file : Path
        The path to the file.

    Returns
    -------
    list[dict[str, str]]
        The parsed data, each entry in the list is one line from tegrastats

    """
    with file.open("r") as f:
        lines = f.readlines()
    
    py_delim = "::"
    python = False
    if py_delim in lines[0]:
        python = True

    entries: list[dict[str, str]] = []
    for line in lines:
        # make entry
        entry: dict[str, str] = {}
        
        # strip newline
        line = line.strip()

        # parse out python timestamp if exists
        timestamp = None
        if python:
            timestamp, line = line.split(py_delim)
        if timestamp:
            entry["timestamp"] = timestamp

        # parse remainder of line
        data = line.split(" ")

        # first two entires are always date and time (minute resolution)
        entry["DATE"] = data[0]
        entry["TIME"] = data[1]
        data = data[2:]

        # from now on each entry is UPPERCASE value
        # additional values will start with (
        # if value is found that starts with (
        # then it will be treaded as UPPERCASE value
        # by removing the ()
        name = None
        paran = False
        for value in data:
            if name is None:
                # handle paran data
                if value[0] == "(":
                    value = value[1:].upper()
                    paran = True
                    name = value
                # handle temp data
                elif "@" in value:
                    soc, temp = value.split("@")
                    temp_name = f"{soc.upper()}_TEMP"
                    entry[temp_name] = temp
                else:
                    name = value
            else:
                if paran:
                    value = value[:-1]
                    paran = False
                    entry[name] = value
                    name = None
                else:
                    entry[name] = value
                    name = None

        # write back the entry
        entries.append(entry)

    return entries

class Tegrastats:
    """Runs tegrastats in a seperate process and stores output in a file."""

    def __init__(
        self: Self,
        output: Path | str,
        interval: int = 1000,
        *,
        readall: bool | None = None,
    ) -> None:
        """
        Create an instance of tegrastats with outputs to a file.

        Parameters
        ----------
        output : Path | str
            The path to the output file
        interval : int, optional
            The interval to run tegrastats in milliseconds, by default 1000
        readall : bool, optional
            Optionally, read all possible information through tegrastats.
            Additional information varies by board.
            Can consume additional CPU resources.
            By default, will NOT readall

        """
        self._output = Path(output)
        self._interval = interval
        self._readall = readall

        self._event = mp.Event()
        self._process = mp.Process(
            target=self._run,
            args=(self._output, self._interval),
            daemon=True,
        )

    def __enter__(self: Self) -> Self:
        # start the process
        self._process.start()

        # need to wait for Flag
        self._event.wait()

        return self

    def __exit__(
        self: Self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        _log.debug("Stopping tegrastats")
        self._process.terminate()
        command = ["tegrastats", "--stop"]
        subprocess.run(
            command,
            check=True,
        )

    def _run(
        self: Self,
        output: Path,
        interval: int,
    ) -> None:
        """
        Target function for process running tegrastats.

        Parameters
        ----------
        output : Path
            The path to the output file.
        interval : int
            The interval to update tegrastats info (ms).

        Raises
        ------
        RuntimeError
            If the process created by Popen does not have stdout/stderr
        CalledProcessError
            If the process has any stderr output

        """
        # maintain the file in open state
        with output.open("w+") as f:
            _log.debug(f"Open file {output} for writing")

            # create the command and run the Popen call
            command = ["tegrastats", "--interval", str(interval)]
            if self._readall:
                command.append("--readall")
            process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1,
            )

            _log.debug(f"Ran tegrastats with command: {command}")

            # ensure stdout/stderr streams exist
            if process.stdout is None or process.stderr is None:
                err_msg = "Cannot access stdout or stderr streams in Tegrastat process."
                raise RuntimeError(err_msg)

            _log.debug("No errors from process found")

            # signal that the process is opened
            self._event.set()

            # read output while it exists
            # this will be stopped by the __exit__ call
            # which will call tegrastats --stop
            # resulting in the lines to cease
            while True:
                line = process.stdout.readline()
                if not line:
                    break
                f.write(f"{time.time()}::{line}")
                f.flush()

            _log.debug("Stopped reading from tegrastats process")

            # check for any errors
            stderr_output = process.stderr.read()
            if stderr_output:
                raise subprocess.CalledProcessError(
                    process.returncode,
                    process.args,
                    stderr=stderr_output,
                )
